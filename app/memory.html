<!DOCTYPE html>
<meta charset="utf-8">
<title>Memorizinator</title>
<style>
    body {
        font-family: Calibri;
        font-size: 12px;
        color: black;
    }

    svg {
        border: 1px solid lightgray;
        width: 100%;
        height: 100%;
    }

    .node {
        stroke: black;
        stroke-width: 0;
    }

    .text { /* centers text in node */
        text-anchor: middle;
        alignment-baseline: central;
        pointer-events: none;
    }

    .next { /* for boldIt hint */
        font-weight: bold;
    }

    .link {
        stroke: lightgray;
        stroke-width: 1px;
    }

    #container {
        position: relative;
        display: inline-block;
        height: 300px;
        width: 500px;
    }

    #hints {
        position: absolute;
        top: 3px;
        left: 3px;
        visibility: hidden;
    }

    #selectText {
        position: absolute;
        top: 3px;
        right: 2px;
    }

    #message {
        position: absolute;
        bottom: 2px;
        left: 3px;
    }

    #restart {
        position: absolute;
        bottom: 2px;
        right: 2px;
    }

</style>
<body>
    <div id="container">
        <svg>
            <rect width="0" height="10" x="157" y="3" id="tmr"></rect>
            <div id="hints">
                <button id="sayit" onclick="gameManager('sayit');" title="Reads the text to you. Click again to silence.">Say It</button>&nbsp;
                <button id="showit" onclick="gameManager('showit');" title="Show the text inthe lower corner. Click again to hide.">Show It</button>&nbsp;
                <button id="boldit" onclick="gameManager('boldit');" title="Bold the next word you need to click. Click again to turn off.">Bold It</button>
            </div>
            <select id="selectText" onchange="newText(value);"></select>
            <div id="message"><b>Memorizinator</b> (A little game to help you learn big ideas.)</div>
            <button id="restart" onclick="gameManager('restart');">Restart</button>
        </svg>
    </div>
</body>
<script src="//d3js.org/d3.v4.js"></script>
<script>
    // General variablees
    var prevClickedID = -1,   // ID of the most recent gnode that was clicked
        allWordData = [],   // All words (data) from text from json
        wordData = [],      // Words loaded (data) into simulation from json
        wordLinks = [],     // Links (data) in the simulation
        w = 500,            // Width of the svg palette
        h = 300,            // Height of the svg palette
        initCount = 7,      // Number of words to show at beginning of game
        answerKey = [],     // A string of wordID's indicating the correct answer
        playerAnswer = [],  // A string of wordID's indicating the player's answer
        foci = [{ x: 100, y: h / 2 }, { x: 350, y: h / 2 }], // Sets 2 foci on page
        defCitation = "Williams Shedd",
        text,               // The text to be memorized
        boldIt = false,     // Is the boltIt hint be active?
        glinks,             // Active links on the game
        gnodes,             // The current set of gnodes
        color;              // Node colors

    // Get svg handle, set up color and radius scale
    var svg = d3.select("svg");
    var radScale = d3.scaleLinear().domain([1, 15]).range([10, 50]);

    // Set forces in the simulation
    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody().strength(-50))
        .force("collide", d3.forceCollide(function (d) { return d.rad; }));

    // Get text from json, then start simulation
    function build(citation) {
        d3.json("/data/texts.json", function (error, textsData) {

            // Populate dropdown if it's empty
            dd = document.getElementById("selectText");
            if (dd.options.length == 0) {
                for (var i = 0; i < textsData.nodes.length; i++) {
                    var el = document.createElement("option");
                    el.textContent = el.value = textsData.nodes[i].cit;
                    el.selected = (textsData.nodes[i].cit == defCitation);
                    dd.appendChild(el);
                }
            }

            // Get and split requested text and split, save text for later use.
            var keyText = textsData.nodes.filter(function (obj) { if (obj.cit == citation) return true; else return false; });
            text = keyText[0].text;
            var kt = text.replace("-", "- ").split(" ");


            // Format data, create answerkey
            for (i = 0; i < kt.length; i++) {
                var firstIndex = kt.indexOf(kt[i]);
                var firstID = firstIndex > -1 ? Math.min(firstIndex, i) : i;
                answerKey.push(firstID);

                allWordData.push({
                    word: kt[i],
                    id: i,
                    wordid: firstID, // identical words have the same wordid
                    x: 0,
                    y: ~~(Math.random() * h),
                    rad: radScale(kt[i].length),
                    show: 0,        // for later use?
                    answerSet: 0    // for later use?
                })
            }
            color = d3.scaleOrdinal().domain(0, 4).range(colorPalette(allWordData.length));


            // Push word data into active dataset
            for (i = 0; i < Math.min(initCount, allWordData.length) ; i++) {
                allWordData[i].show = 1;
                wordData.push(allWordData[i]);
            }

            // for (i = 0; i < textsData.links.length ; i++) { wordLinks.push(textsData.links[i]); }

            gameManager("start");
            start();
        });
    }
    build(defCitation);


    // Build the force simulation
    function start() {

        // Create links
        glinks = svg.selectAll(".link")
            .data(wordLinks, function (d) { return d.source.id + "-" + d.target.id; })
            .enter().insert("line", ".gnode").attr("class", "link");
        glinks.exit().remove();

        // Create nodes (well, g-elements).  Add circles, text, & event listeners
        gnodes = svg.selectAll("g")
            .data(wordData, function id(d, i) { return d.id; })
            .enter().append("g").attr("class", function (d) { return "gnode g" + d.id; })
            .classed("next", function (d) { return (boldIt && d.wordid == 0) ? true : false ; });
        gnodes.exit().remove();

        var circles = gnodes.append("circle").attr("class", function (d) { return "c" + d.id; })
            .attr("r", function (d) { return d.rad; }).style("fill", function (d, i) { return color(d.id); })
            .attr("opacity", 0.7);

        var texts = gnodes.append("text")
            .attr("class", function (d) { return "text w" + d.id; }) // Tie into CSS
            .text(function (d) { return (d.word); });

        var actions = gnodes.on("dblclick", nodeClicked)
            .call(d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded));

        // Link data to simulation and set it in motion.
        simulation.nodes(wordData)
            .force("link").links(wordLinks);

        simulation.on("tick", ticked)
            .alpha(0.5)
            .restart();
    }

    // Manage node & link movement
    function ticked(e) {
        var k = .2 * simulation.alpha();

        svg.selectAll(".gnode").attr("transform", function (d) {
            // Set node location, multi-foci
            d.y += (foci[d.answerSet].y - d.y) * k;
            d.x += (foci[d.answerSet].x - d.x) * k;

            // But be sure that nodes don't go out-of-bounds
            d.y = Math.max(d.rad, Math.min(h - d.rad, d.y));
            d.x = Math.max(d.rad, Math.min(w - d.rad, d.x));

            return 'translate(' + [d.x, d.y] + ')';
        });

        // Set link locations
        svg.selectAll(".link")
            .attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });
    }

    function dragStarted(d) {
        d3.select(this).raise().classed("active", true);
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragEnded(d) {
        d3.select(this).classed("active", false);
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    // User (double) clicked a node
    function nodeClicked(d) {
        if (d.answerSet == 0) {
            d.answerSet = 1; // Moves the gnode over to the answer side.
            if (allWordData.length > wordData.length) {
                allWordData[wordData.length].show = 1;
                wordData.push(allWordData[wordData.length]); // Gets the next word.
            }

            // Add a link
            if (prevClickedID != -1) { wordLinks.push({ "source": prevClickedID, "target": d.id }); }
            start();

            // Update prevClickedID and check the answer
            prevClickedID = d.id;
            playerAnswer.push(d.wordid);    // Update the players answer
            svg.selectAll(".text")          // Bold next word
                .classed("next", function (d) { return (boldIt && d.wordid == answerKey[playerAnswer.length]) ? true : false; });
            if (playerAnswer.toString() == answerKey.toString()) { gameManager("win"); } // Check answer or error
            else if (playerAnswer.toString() != answerKey.slice(0, playerAnswer.length).toString()) { gameManager("incorrect"); }
        } else {

            var unwind = [];
            var found = false;
            for (i = 0; i < playerAnswer.length; i++) {
                if (playerAnswer[i] == d.wordid || found) {
                    found = true;
                    unwind.push(playerAnswer[i]);
                    //svg.select(".gnode").call
                }
            }
            //alert(unwind);          
        }
    }

    function colorPalette(id) {
        var palettes = [["#3dc8ff", "#ff3d87", "#ff703d", "#ffc83d", "#e1ff3d"],
            ["#493548", "#4b4e6d", "#6a8d92", "#80b192", "#a1e887"],
            ["#335c67", "#fff3b0", "#e09f3e", "#9e2a2b", "#540b0e"],
            ["#4d9de0", "#e15554", "#e1bc29", "#3bb273", "#7768ae"],
            ["#202030", "#39304a", "#635c51", "#7d7461", "#b0a990"]];
        return palettes[(id % palettes.length)];
    }


// ********** Begin Game Mechanics / Management **********
    var message = document.getElementById("message"),   // Get handle on the message DIV
        tmrRect = document.getElementById("tmr"),
        timer,                                          // Allows timer to be managed from multiple places
        timerLength = 20;                               // Allows clean management of timer length

    function gameManager(event) {

        switch (event) {
            case "incorrect":
                message.innerHTML = "<b>There's a problem...</b>";
                break;
            case "timerBar":
                tmrRect.setAttribute("width", timerLength * 2);
                tmrRect.setAttribute("fill", (timerLength > 10 ? color(0) : color(4)));
                break;
            case "start":
                timerLength = ~~(allWordData.length * 1.5);
                clearInterval(timer);
                timer = setInterval(gameTimer, 1000);
                message.innerHTML = "Double-click the words in the correct order.";
                document.getElementById("hints").style.visibility = "visible";
                break;
            case "win":
                message.innerHTML = "<b>You WON! Score = " + timerLength + 1 + "</b>";
                document.getElementById("hints").style.visibility = "hidden";
                clearInterval(timer);
                break;
            case "loss":
                message.innerHTML = "I'm sorry for your loss.";
                document.getElementById("hints").style.visibility = "hidden";
                clearInterval(timer);
                break;
            case "restart":
                var sel = document.getElementById("selectText");
                newText(sel.options[sel.selectedIndex].text);
                break;
            case "sayit":
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                } else {
                    var msg = new SpeechSynthesisUtterance(text);
                    window.speechSynthesis.speak(msg);
                    message.innerHTML = "[Say It only works in Chrome browser.]";
                }
                break;
            case "boldit":
                boldIt = !boldIt;
                message.innerHTML = "Bolding: " + (boldIt ? "On" : "Off");
                break;
            case "showit":
                if (message.innerHTML == text) { message.innerHTML = ""; }
                else { message.innerHTML = text; }
                break;
        }
    }


    function gameTimer() {
        if (timerLength >= 0) {
            gameManager("timerBar");
            timerLength--
        } else {
            gameManager("loss")
            clearInterval(timer);
        }
    }


    function newText(newValue) {
        prevClickedID = -1;   // ID of the most recent gnode that was clicked
        allWordData = [];   // All words (data) from text from json
        wordData = [];      // Words loaded (data) into simulation from json
        wordLinks = [];     // Links (data) in the simulation
        answerKey = [];     // The right answer
        playerAnswer = [];  //

        d3.selectAll("svg > g").remove();
        start();
        build(newValue);
    }


</script>
