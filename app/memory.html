<!DOCTYPE html>
<meta charset="utf-8">
<title>Memorizinator</title>
<link href="/resource/SkinnySkeleton.css" rel="stylesheet" />
<style>

    #gameboard {
        border: 1px solid #840000;
        width: 100%;
        height: 100%;
    }

    .node {
        stroke: black;
        stroke-width: 0;
        
    }

    .text { /* centers text in node */
        text-anchor: middle;
        alignment-baseline: central;
        pointer-events: none;
    }

    .next { /* for boldIt hint */
        font-weight: bold;
    }

    .link {
        stroke: lightgray;
        stroke-width: 1px;
    }

    #container {
        position: relative;
        display: inline-block;
        height: 300px;
        width: 600px;
    }


    #selectText {
        position: absolute;
        top: 3px;
        right: 2px;
    }

    #message {
        position: absolute;
        bottom: 2px;
        left: 3px;
    }

    #restart {
        position: absolute;
        bottom: 2px;
        right: 2px;
    }

    #settings {
        position: absolute;
        bottom: 2px;
        right: 24px; 
    }

    #popup {
	    display: none;
	    position: absolute;
        line-height: 200%;
	    top: 30%;
	    left: 20%;
	    width: 60%;
	    height: 40%;
	    padding: 10px;
	    border: 1px solid gray;
	    background-color: white;
	    z-index:1002;
	    overflow: auto;
        box-shadow: 0 0 0 1000em rgba(0,0,0,.5);
    }

    #timerBar {
        fill: #840000;
        opacity: 0.7;
    }

    #timerBarBox {
        fill: #e0e0e2;
        opacity: 0.7;
   }
</style>
<body>
    <div id="container">
        <svg id="gameboard">
            <rect width="0" height="10" x="3" y="3" id="timerBarBox"></rect><rect width="0" height="10" x="3" y="3" id="timerBar"></rect>
            <div>
            </div>
            <select id="selectText" onchange="newText(value);"></select>
            <div id="message"><b>Memorizinator</b> (A little game to help you learn big ideas.)</div>

            <svg class="svg-button" id="settings" onclick="document.getElementById('popup').style.display = 'block';" viewBox="0 0 24 24"><path d="M24 14.187v-4.374c-2.148-.766-2.726-.802-3.027-1.529-.303-.729.083-1.169 1.059-3.223l-3.093-3.093c-2.026.963-2.488 1.364-3.224 1.059-.727-.302-.768-.889-1.527-3.027h-4.375c-.764 2.144-.8 2.725-1.529 3.027-.752.313-1.203-.1-3.223-1.059l-3.093 3.093c.977 2.055 1.362 2.493 1.059 3.224-.302.727-.881.764-3.027 1.528v4.375c2.139.76 2.725.8 3.027 1.528.304.734-.081 1.167-1.059 3.223l3.093 3.093c1.999-.95 2.47-1.373 3.223-1.059.728.302.764.88 1.529 3.027h4.374c.758-2.131.799-2.723 1.537-3.031.745-.308 1.186.099 3.215 1.062l3.093-3.093c-.975-2.05-1.362-2.492-1.059-3.223.3-.726.88-.763 3.027-1.528zm-4.875.764c-.577 1.394-.068 2.458.488 3.578l-1.084 1.084c-1.093-.543-2.161-1.076-3.573-.49-1.396.581-1.79 1.693-2.188 2.877h-1.534c-.398-1.185-.791-2.297-2.183-2.875-1.419-.588-2.507-.045-3.579.488l-1.083-1.084c.557-1.118 1.066-2.18.487-3.58-.579-1.391-1.691-1.784-2.876-2.182v-1.533c1.185-.398 2.297-.791 2.875-2.184.578-1.394.068-2.459-.488-3.579l1.084-1.084c1.082.538 2.162 1.077 3.58.488 1.392-.577 1.785-1.69 2.183-2.875h1.534c.398 1.185.792 2.297 2.184 2.875 1.419.588 2.506.045 3.579-.488l1.084 1.084c-.556 1.121-1.065 2.187-.488 3.58.577 1.391 1.689 1.784 2.875 2.183v1.534c-1.188.398-2.302.791-2.877 2.183zm-7.125-5.951c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3zm0-2c-2.762 0-5 2.238-5 5s2.238 5 5 5 5-2.238 5-5-2.238-5-5-5z" /></svg>
            <svg class="svg-button" id="restart" onclick="gameManager('restart');" viewBox="0 0 24 24"><path d="M13.427 3.021h-7.427v-3.021l-6 5.39 6 5.61v-3h7.427c3.071 0 5.561 2.356 5.561 5.427 0 3.071-2.489 5.573-5.561 5.573h-7.427v5h7.427c5.84 0 10.573-4.734 10.573-10.573s-4.733-10.406-10.573-10.406z"/></svg>
            <div id="popup">
                <div class="row">
                    <div class="ten columns"><h4>Settings</h4></div>
                    <div class="button two columns" onclick="document.getElementById('popup').style.display='none';">X</div>
                </div>
                <hr />
                <div class="row">
                    <div class="button four columns" id="sayit" onclick="gameManager('sayit');" title="Reads the text to you. Click again to silence.">Say It</div>
                    <div class="button four columns" id="showit" onclick="gameManager('showit');" title="Show the text inthe lower corner. Click again to hide.">Show It</div>
                    <div class="button four columns" id="boldit" onclick="gameManager('boldit');" title="Bold the next word you need to click. Click again to turn off.">Bold It</div>
                </div>
</svg>
    </div>
</body>
<script src="//d3js.org/d3.v4.js"></script>
<script>
    // General variablees
    var allWordData = [],   // All words (data) from text from json
        wordData = [],      // Words loaded (data) into simulation from json
        wordLinks = [],     // Links (data) in the simulation
        svgWidth = 600,     // Width of the svg palette
        svgHeight = 300,    // Height of the svg palette
        initCount = 7,      // Number of words to show at beginning of game
        answerKey = [],     // An array of wordID's indicating the correct answer
        playerAnswer = [],  // An array of wordID's indicating the player's answer
        clickedID = [],     // An array of the players answers
        foci = [{ x: 150, y: svgHeight / 2 }, { x: 450, y: svgHeight / 2 }], // Sets 2 foci on page
        defCitation = "Williams Shedd",
        text,               // The text to be memorized
        boldIt = false,     // Is the boltIt hint be active?
        color;              // Node colors

    // Get svg handle, set up color and radius scale (use word length to set size)
    var svg = d3.select("svg");
    var radScale = d3.scaleLinear().domain([1, 15]).range([10, 50]);

    // Set forces in the simulation
    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(function (d) { return d.id; }))
        .force("charge", d3.forceManyBody().strength(-50))
        .force("collide", d3.forceCollide(function (d) { return d.rad; }));

    // Get text from json, then start simulation
    function build(citation) {
        d3.json("/data/texts.json", function (error, textsData) {

            // Populate dropdown if it's empty
            dd = document.getElementById("selectText");
            if (dd.options.length == 0) {
                for (var i = 0; i < textsData.nodes.length; i++) {
                    var el = document.createElement("option");
                    el.textContent = el.value = textsData.nodes[i].cit;
                    el.selected = (textsData.nodes[i].cit == citation);
                    dd.appendChild(el);
                }
            }

            // Get and split requested text and split, save text for later use.
            var keyText = textsData.nodes.filter(function (obj) { if (obj.cit == citation) return true; else return false; });
            text = keyText[0].text;
            var kt = text.replace("-", "- ").split(" ");


            // Format data, create answerkey
            for (i = 0; i < kt.length; i++) {
                var firstIndex = kt.indexOf(kt[i]);
                var firstID = firstIndex > -1 ? Math.min(firstIndex, i) : i;
                answerKey.push(firstID);

                allWordData.push({
                    word: kt[i],
                    id: i,
                    wordid: firstID, // identical words have the same wordid
                    x: 0,
                    y: ~~(Math.random() * svgHeight),
                    rad: radScale(kt[i].length),
                    clickOrder: 0,  // for later use?
                    answerSet: 0    // for later use?
                })
            }
            color = d3.scaleOrdinal().domain(0, 4).range(colorPalette(allWordData.length));


            // Push word data into active dataset
            for (i = 0; i < Math.min(initCount, allWordData.length) ; i++) {
                allWordData[i].show = 1;
                wordData.push(allWordData[i]);
            }

            // for (i = 0; i < textsData.links.length ; i++) { wordLinks.push(textsData.links[i]); }

            gameManager("start");
            start();
        });
    }
    build(defCitation);


    // Build the force simulation
    function start() {

        // Create links
        var glinks = svg.selectAll(".link")
            .data(wordLinks, function (d) { return d.source.id + "-" + d.target.id; })
            .enter().insert("line", ".gnode").attr("class", "link");
        //glinks.exit().remove();

        // Create nodes (well, g-elements).  Add circles, text, & event listeners
        var gnodes = svg.selectAll("g")
            .data(wordData, function id(d, i) { return d.id; })
            .enter().append("g").attr("class", function (d) { return "gnode g" + d.id; })
            .classed("next", function (d) { return (boldIt && d.wordid == 0) ? true : false ; });
        //gnodes.exit().remove();

        var circles = gnodes.append("circle").attr("class", function (d) { return "c" + d.id; })
            .attr("r", function (d) { return d.rad; }).style("fill", function (d, i) { return color(d.id); })
            .attr("opacity", 0.7);

        var texts = gnodes.append("text")
            .attr("class", function (d) { return "text w" + d.id; }) // Tie into CSS
            .text(function (d) { return (d.word); });

        var actions = gnodes.on("click", nodeClicked);

        // Link data to simulation and set it in motion.
        simulation.nodes(wordData).force("link").links(wordLinks);
        simulation.on("tick", ticked).alpha(0.5).restart();
    }

    // Manage node & link movement
    function ticked(e) {
        var k = .2 * simulation.alpha();

        svg.selectAll(".gnode").attr("transform", function (d) {
            // Set node location, multi-foci
            d.y += (foci[d.answerSet].y - d.y) * k;
            d.x += (foci[d.answerSet].x - d.x) * k;

            // But be sure that nodes don't go out-of-bounds
            d.y = Math.max(d.rad, Math.min(svgHeight - d.rad, d.y));
            d.x = Math.max(d.rad, Math.min(svgWidth - d.rad, d.x));

            return 'translate(' + [d.x, d.y] + ')';
        });

        // Set link locations
        svg.selectAll(".link")
            .attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });
    }

    // User clicked a node
    function nodeClicked(d) {
        if (d.answerSet == 0) {
            d.answerSet = 1; // Moves the gnode over to the answer side.
            if (allWordData.length > wordData.length) {
                allWordData[wordData.length].show = 1;
                wordData.push(allWordData[wordData.length]); // Gets the next word.
            }

            // Add a link between last clicked and new clicked
            if (clickedID.length > 0) { wordLinks.push({ "source": clickedID.slice(-1)[0], "target": d.id }); }
            start();

            // Update clickedID and check the answer
            clickedID.push(d.id);
            playerAnswer.push(d.wordid);    // Update the players answer
            svg.selectAll(".text")          // Bold next word
                .classed("next", function (d) { return (boldIt && d.wordid == answerKey[playerAnswer.length]) ? true : false; });
            if (playerAnswer.toString() == answerKey.toString()) { gameManager("win"); } // Check answer or error
            else if (playerAnswer.toString() != answerKey.slice(0, playerAnswer.length).toString()) { gameManager("incorrect"); }
        } else {   // d.answerSet == 1
            d.answerSet == 0;
            for (var i = clickedID.length - 1; i >= 0; i--) {
                id = clickedID[i];
                d3.select(".g" + id + " > .c" + id).attr("opacity", 1);
                findLinks(id)
                if (id == d.id) break;
            }
            start();
            // reset foci
            // mark as answer = false

        }
    }

    function findNode(id) {

    }

    function findLinks(id) {
        for (var i = 0; i < wordLinks.length; i++) {
            if (id == wordLinks[i].source["id"] || id == wordLinks[i].target["id"]) {
                //alert(id);
            }

            //if (clickedID[i] == d.id) break;
        }
    }

    function colorPalette(id) {
        var palettes = [["#3dc8ff", "#ff3d87", "#ff703d", "#ffc83d", "#e1ff3d"],
            ["#493548", "#4b4e6d", "#6a8d92", "#80b192", "#a1e887"],
            ["#335c67", "#fff3b0", "#e09f3e", "#9e2a2b", "#540b0e"],
            ["#4d9de0", "#e15554", "#e1bc29", "#3bb273", "#7768ae"],
            ["#202030", "#39304a", "#635c51", "#7d7461", "#b0a990"]];
        return palettes[(id % palettes.length)];
    }


// ********** Begin Game Mechanics / Management **********
    var message = document.getElementById("message"),   // Get handle on the message DIV
        timer,                                          // Allows timer to be managed from multiple places
        timerLength = 20;                               // Allows clean management of timer length

    var timerBar = d3.select("#timerBar"),
        timerBarBox = d3.select("#timerBarBox");

    function gameManager(event) {

        switch (event) {
            case "incorrect":
                message.innerHTML = "<b>There's a problem...</b>";
                break;
            case "timerBar":
                timerBar.attr("width", timerLength * 2).attr("opacity", (timerLength > 10 ? 0.7 : 1));
                break;
            case "start":
                timerLength = ~~(allWordData.length * 1.5);
                clearInterval(timer);
                timer = setInterval(gameTimer, 1000);
                timerBar.attr("width", timerLength * 2);
                timerBarBox.attr("width", timerLength * 2);
                message.innerHTML = "Click the words in the correct order.";
                break;
            case "win":
                message.innerHTML = "<b>You WON! Score = " + timerLength + 1 + "</b>";
                timerBarBox.attr("width", 0);
                timerBar.attr("width", 0);
                clearInterval(timer);
                break;
            case "loss":
                message.innerHTML = "I'm sorry for your loss.";
                timerBarBox.attr("width", 0);
                clearInterval(timer);
                break;
            case "restart":
                var sel = document.getElementById("selectText");
                newText(sel.options[sel.selectedIndex].text);
                break;
            case "sayit":
                if (window.speechSynthesis.speaking) {
                    window.speechSynthesis.cancel();
                } else {
                    var msg = new SpeechSynthesisUtterance(text);
                    window.speechSynthesis.speak(msg);
                    message.innerHTML = "[Say It only works in Chrome browser.]";
                }
                break;
            case "boldit":
                boldIt = !boldIt;
                message.innerHTML = "Bolding: " + (boldIt ? "On" : "Off");
                break;
            case "showit":
                if (message.innerHTML == text) { message.innerHTML = ""; }
                else { message.innerHTML = text; }
                break;
        }
    }


    function gameTimer() {
        if (timerLength-- >= 0) {
            gameManager("timerBar");
        } else {
            gameManager("loss")
            clearInterval(timer);
        }
    }


    function newText(newValue) {
        clickedID = [];
        allWordData = [];   // All words (data) from text from json
        wordData = [];      // Words loaded (data) into simulation from json
        wordLinks = [];     // Links (data) in the simulation
        answerKey = [];     // The right answer
        playerAnswer = [];  //

        d3.selectAll("g, .link").remove();
        start();
        build(newValue);
    }

</script>